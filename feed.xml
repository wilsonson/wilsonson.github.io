<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://wilsonson.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://wilsonson.github.io//" rel="alternate" type="text/html" /><updated>2021-08-29T02:13:53+08:00</updated><id>https://wilsonson.github.io//feed.xml</id><title type="html">Wilsonson Blog</title><subtitle>A blog of my geek journey so far.</subtitle><author><name>Wilson Yeung</name></author><entry><title type="html">Performance Test</title><link href="https://wilsonson.github.io//blog/performance-test/" rel="alternate" type="text/html" title="Performance Test" /><published>2021-08-29T00:00:00+08:00</published><updated>2021-08-29T00:00:00+08:00</updated><id>https://wilsonson.github.io//blog/performance-test</id><content type="html" xml:base="https://wilsonson.github.io//blog/performance-test/">&lt;p&gt;Most developers should have the experience to be asked by the senior or other business stakeholders for conducting load tests. The so-called load test is all about performance, and it’s aimed to find out all the limitations/bottlenecks of an application. 
When we assess the performance of an application, there’re a few metrics we will think about, and, of course, CPU utilization is always the first metric we will put our eyes on. But other than CPU utilization, there’re a few metrics we should consider. Here’s the list of common metrics, which I will check on it.&lt;/p&gt;

&lt;h1 id=&quot;cpu-utilization&quot;&gt;CPU Utilization&lt;/h1&gt;
&lt;p&gt;CPU utilization is the most straightforward one. When you think an application has a performance issue, you should check on CPU usage. And if the overall CPU utilization is high, you may need to check the application to find out the code consuming computation power. Besides, you may also check how many CPU cores are using by the application. Usually, a high-loading application should spread the loading over all available CPU cores. If the application relies on a single CPU core, you may consider rewriting the code to distribute the loading with multiple threads or await / async approach.&lt;/p&gt;

&lt;h1 id=&quot;memory-utilization&quot;&gt;Memory Utilization&lt;/h1&gt;
&lt;p&gt;I think no application is intentionally designed to run out of memory. So an application should have a way to recycle the memory and keeping it in a good state. Otherwise, it will drain too much memory, making other applications run abnormally, or the OS will handle the issue, by simply killing the overloaded application, to protect the system. 
When an application starts running, it will consume memory quickly until all required data has been loaded. Generally speaking, an application should consume and release memory under normal/expected usage. If your application consumes more and more memory over time, you may need to find out why it’s not releasing the memory, such as memory leakage, not necessary cache…etc. For remedial, you may need to regularly restart your application, or even OS if even worse.&lt;/p&gt;

&lt;h1 id=&quot;disk-throughput&quot;&gt;Disk Throughput&lt;/h1&gt;
&lt;p&gt;When an application needs to read or write files frequently, it may hit the performance bottleneck because of OS, file system, or hardware. Generally, if an application reads or writes files on a disk, it’s relying on the OS to communicate with the disk to do I/O operations. So if there’s an issue with OS’s driver, it may cause some trouble. When an application needs to read/write multiple small files, the file system (e.g. FAT32, NTFS, ext4) may also be a factor that will impact the performance. 
And, of course, the technology of the hardware disk is also a significant factor. The performance of SSD is much better than the traditional mechanical disk, despite cost &amp;amp; disk size. Besides the disk technology, sometimes we will use RAID, i.e. combine multiple disks, to boost the performance.&lt;/p&gt;

&lt;p&gt;Disk throughput is a limitation that you can’t avoid if your application needs to read/write heavily. However, you can still consider a few things to avoid the issue, like creating the data cache on memory, putting the data into a database server.&lt;/p&gt;

&lt;h1 id=&quot;network-throughput&quot;&gt;Network Throughput&lt;/h1&gt;
&lt;p&gt;Generally speaking, a network is composed of multiple elements, like NIC, Hub / Switch, cable ..etc. ( I don’t want to go deep into 7-layers design, but I always think a good developer should know the network ). So if your application hits a network throughput issue, you should consider the machine that runs your application and think about the whole network, including the application/machines on the same network, the elements in between, and, of course, the outbound bandwidth. And despite bandwidth, you need to check whether any network element is dropping the packets because of too much traffic or simply faulty hardware. Besides, if your application uses UDP, you may take extra care because UDP has less control over the packet transmission. And if your application is using VPN, please need to consider if MTU is causing you trouble.&lt;/p&gt;

&lt;h1 id=&quot;number-of-socket--port&quot;&gt;Number of Socket / Port&lt;/h1&gt;
&lt;p&gt;This one is a rare issue, but it happens, especially when your application is calling web API intensively. Theoretically, there are 65535 ports for an IP address, but the OS or some system applications has already reserved or used some ports. The actual number of ports that your application can use is limited, around 20K – 30K. When your application makes an HTTP API call to the external, the application will get a port from the OS to create a connection. After the API call is done, the application closes the connection by closing the port. However, the closing procedure is not a sharply cut operation under the TCP. It will put the port into the state of “TIME_WAIT” and wait for timeout, generally 2 minutes. (You may check the TCP state diagram &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Tcp_state_diagram_fixed.svg&quot;&gt;here&lt;/a&gt; .) And then, when the application makes another API call and doesn’t reuse the same port obtained before, the OS needs to provide another port. So you can see the problem here: If your application consuming ports faster than the OS can release it, the application will run out of ports eventually. When you suspect your care running out of port, you may check with the command “netstat -an” to see how many ports are in use. And to prevent this issue, you need to code your application to reuse the port as much as possible.&lt;/p&gt;</content><author><name>Wilson Yeung</name></author><category term="blog" /><summary type="html">Most developers should have the experience to be asked by the senior or other business stakeholders for conducting load tests. The so-called load test is all about performance, and it’s aimed to find out all the limitations/bottlenecks of an application. When we assess the performance of an application, there’re a few metrics we will think about, and, of course, CPU utilization is always the first metric we will put our eyes on. But other than CPU utilization, there’re a few metrics we should consider. Here’s the list of common metrics, which I will check on it.</summary></entry><entry><title type="html">New blog!</title><link href="https://wilsonson.github.io//blog/new-blog/" rel="alternate" type="text/html" title="New blog!" /><published>2021-08-20T00:00:00+08:00</published><updated>2021-08-20T00:00:00+08:00</updated><id>https://wilsonson.github.io//blog/new-blog</id><content type="html" xml:base="https://wilsonson.github.io//blog/new-blog/">&lt;p&gt;After many years of coding, I decided to write down some notes for myself. Hopefully, these experiences can also help others.&lt;/p&gt;</content><author><name>Wilson Yeung</name></author><category term="blog" /><summary type="html">After many years of coding, I decided to write down some notes for myself. Hopefully, these experiences can also help others.</summary></entry></feed>